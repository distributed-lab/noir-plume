use crate::hash_to_field::hash_to_field;
use crate::map_to_curve::map_to_curve;
use crate::iso_map::iso_map;
use crate::ec_ops::{Point, point_add};

// Based on https://github.com/geometryxyz/secp256k1_hash_to_curve code
pub fn hash_to_curve<let N: u32>(msg: [u8; N]) -> Point {
    let u = hash_to_field(msg);

    let q0 = map_to_curve(u.0);
    let q1 = map_to_curve(u.1);

    point_add(iso_map(q0), iso_map(q1))
}

/*
These test cases are commented out because they depend on the PLUME_MSG_LEN constant.
If the msg.len() in test case is not equal to PLUME_MSG_LEN, then it Failed
*/

/*
// To test a specific test, change the value of MSG_LEN to the length of the "msg" variable

use std::bigint::Secpk1Fq;

// Test cases are taken from https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-13.html#name-secp256k1_xmdsha-256_sswu_r
#[test]
fn test_hash_to_curve_for_empty_msg() {
    let msg = [];
    let (px, py) = hash_to_curve(msg);

    let expected_px = Secpk1Fq::from_le_bytes(
        &[
        70, 19, 235, 223, 45, 133, 181, 183,
        169, 171, 30, 132, 139, 196, 121, 20,
        134, 115, 109, 190, 241, 174, 235, 23,
        230, 174, 145, 226, 144, 226, 202, 193
    ]
    );
    let expected_py = Secpk1Fq::from_le_bytes(
        &[
        103, 16, 229, 96, 169, 6, 196, 100,
        27, 169, 195, 150, 201, 133, 89, 225,
        109, 175, 148, 42, 2, 139, 240, 38,
        97, 17, 174, 7, 142, 103, 250, 100
    ]
    );
    assert(px == expected_px);
    assert(py == expected_py);
}

#[test]
fn test_hash_to_curve_for_msg_abc() {
    let msg = [97, 98, 99];
    let (px, py) = hash_to_curve(msg);

    let expected_px = Secpk1Fq::from_le_bytes(
        &[
        75, 44, 203, 179, 31, 241, 159, 189,
        96, 87, 32, 249, 249, 236, 182, 114,
        238, 108, 12, 18, 147, 34, 81, 107,
        41, 219, 66, 171, 30, 224, 119, 51
    ]
    );
    let expected_py = Secpk1Fq::from_le_bytes(
        &[
        246, 113, 131, 156, 123, 108, 124, 72,
        141, 104, 148, 111, 17, 182, 15, 144,
        224, 190, 177, 1, 42, 56, 77, 4,
        209, 235, 239, 51, 15, 137, 149, 127
    ]
    );
    assert(px == expected_px);
    assert(py == expected_py);
}

#[test]
fn test_hash_to_curve_for_msg_abcdef0123456789() {
    // msg.len() = 16
    let msg = [97, 98, 99, 100, 101, 102, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57];
    let (px, py) = hash_to_curve(msg);

    let expected_px = Secpk1Fq::from_le_bytes(
        &[
        58, 14, 75, 103, 208, 36, 179, 72,
        88, 243, 211, 132, 203, 165, 131, 7,
        169, 10, 38, 55, 1, 167, 228, 8,
        254, 241, 147, 242, 131, 64, 197, 186
    ]
    );
    let expected_py = Secpk1Fq::from_le_bytes(
        &[
        40, 216, 88, 151, 161, 188, 39, 238,
        189, 152, 179, 86, 231, 220, 106, 23,
        64, 156, 56, 244, 252, 96, 139, 80,
        196, 195, 212, 133, 96, 71, 54, 68
    ]
    );
    assert(px == expected_px);
    assert(py == expected_py);
}

#[test]
fn test_hash_to_curve_for_msg_q128() {
    // msg.len() = 133
    let msg = [
        113, 49, 50, 56, 95, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
        113, 113, 113, 113, 113, 113
    ];
    let (px, py) = hash_to_curve(msg);

    let expected_px = Secpk1Fq::from_le_bytes(
        &[
        233, 144, 24, 228, 2, 177, 114, 127,
        42, 245, 171, 155, 131, 83, 184, 239,
        29, 136, 30, 31, 2, 47, 86, 170,
        55, 58, 51, 133, 199, 123, 22, 226
    ]
    );
    let expected_py = Secpk1Fq::from_le_bytes(
        &[
        115, 216, 133, 102, 30, 106, 73, 184,
        159, 150, 62, 165, 198, 251, 25, 55,
        118, 100, 213, 124, 54, 79, 237, 255,
        103, 88, 195, 92, 217, 29, 64, 242
    ]
    );
    assert(px == expected_px);
    assert(py == expected_py);
}

#[test]
fn test_hash_to_curve_for_msg_a512() {
    // msg.len() = 517
    let msg = [
        97, 53, 49, 50, 95, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
        97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97
    ];
    let (px, py) = hash_to_curve(msg);

    let expected_px = Secpk1Fq::from_le_bytes(
        &[
        152, 201, 183, 140, 31, 140, 253, 230,
        228, 82, 129, 35, 56, 173, 213, 190,
        213, 229, 126, 10, 10, 138, 232, 71,
        182, 185, 240, 170, 90, 211, 200, 227
    ]
    );
    let expected_py = Secpk1Fq::from_le_bytes(
        &[
        166, 58, 130, 229, 142, 136, 181, 36,
        48, 128, 227, 199, 37, 71, 12, 47,
        204, 33, 34, 38, 78, 210, 169, 86,
        47, 241, 27, 24, 182, 238, 70, 132
    ]
    );
    assert(px == expected_px);
    assert(py == expected_py);
}
*/
